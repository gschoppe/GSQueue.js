/**
 * @module GSQueue.js
 * @author Greg Schoppe <contact@gschoppe.com>
 * @copyright 2024
 * @license MIT
 */
export class GSQueue{#e=4294967295;#t;#n;#s;construct(e=[]){this.#t=null,this.#n=null,this.#s=0;for(let t=e.length-1;t>=0;t--)this.enqueue(e[t])}get length(){return this.#s}enqueue(...e){if(this.#s>=this.#e)throw new Error("Queue length cannot exceed "+this.#e+" nodes.");for(const t of e){let e={data:t,next:null};this.#s?this.#t.next=e:this.#n=e,this.#t=e,this.#s++}}enqueueAll(...e){for(const t of e)if(t instanceof GSQueue){let e=t.#n,n=t.#t;if(!e||!n)continue;this.#t?(this.#t.next=e,this.#t=n):(this.#t=n,this.#n=e)}else{if(!(t instanceof Array))throw new Error("Invalid Queue Format. Queues must be an instance of `GSQueue` or an `Array` of values.");this.enqueue(...t)}}dequeue(){if(this.#s<=0)throw new Error("Cannot perform dequeue on an empty Queue.");const e=this.#n;return this.#n=e.next,e==this.#t&&(this.#t=null),this.#s--,e.data}toJSON(){return JSON.stringify(this.toArray())}toString(){return this.toArray().toString()}toArray(){const e=[];if(!this.#s)return e;let t=this.#n;do{e.push(t),t=t.next}while(t);return e}}
